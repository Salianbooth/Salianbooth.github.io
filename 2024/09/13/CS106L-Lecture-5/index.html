<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="referrer" content="no-referrer" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Salianbooth">





<title>CS106L:Lecture 5 | Alan Chen&#39;s blog</title>



    <link rel="icon" href="/image/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Salianbooth&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Salianbooth&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CS106L:Lecture 5</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Salianbooth</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 13, 2024&nbsp;&nbsp;9:00:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/CS106L/">CS106L</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="TO-do-list"><a href="#TO-do-list" class="headerlink" title="TO-do list"></a>TO-do list</h1><ol>
<li><del>const + photo +  非const函数无法使用const变量</del></li>
<li><del>operator overload</del></li>
<li><del>POLA</del></li>
<li>spaceship in C++20</li>
<li><del>copy constructor &amp; copy assignment</del></li>
<li><del>rvalue &amp; lvalue</del></li>
<li>empalce_back</li>
<li><del>move constructor</del></li>
<li><del>include &amp; using namespace</del></li>
<li>~~virtual function &amp; pure</li>
</ol>
<blockquote>
<p>这一节课主要讲了一些和面向对象有关的内容，主要包括重写操作符，构造函数，虚函数，继承等有关。这些在之前的<a href="https://salianbooth.github.io/2024/08/02/C-Primer-learning/">C++Primer</a>中还是粗略的学过，感觉这次的课程主要就是为之前学习的C++进行巩固加深。</p>
</blockquote>
<h1 id="1-Const"><a href="#1-Const" class="headerlink" title="1.Const"></a>1.Const</h1><p>对于const的话，我之前又专门写过一篇博客来区分底层const和顶层const的区别，这次的课程着重介绍了const在函数和class中应用，所以这次就让我们一起仔细地探索const的所有用途。</p>
<h2 id="1-1-const基本用法"><a href="#1-1-const基本用法" class="headerlink" title="1.1 const基本用法"></a>1.1 const基本用法</h2><p>const最基础的用法就是声明常量，虽然在C++11中引入了一个新的关键字<code>constexpr</code>用于声明常量，但是还是<code>const</code>用途更广泛，下面是示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// x 是常量，不能被修改</span></span><br><span class="line">x = <span class="number">20</span>;           <span class="comment">// 错误，x 是常量，无法修改</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2const和指针"><a href="#1-2const和指针" class="headerlink" title="1.2const和指针"></a>1.2const和指针</h2><ol>
<li>指向const对象的指针<br> 这种指针指向的是不可以修改的对象，但是可以修改指针本身：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr;   <span class="comment">// 指向 const int 的指针</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">ptr = &amp;x;        <span class="comment">// 可以指向 x</span></span><br><span class="line">*ptr = <span class="number">20</span>;       <span class="comment">// 错误，不能通过 ptr 修改 x 的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>const指针<br> 这种指针不能修改指向的对象，但是能修改对象的值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;   <span class="comment">// 常量指针，ptr 的地址不能修改</span></span><br><span class="line">*ptr = <span class="number">20</span>;             <span class="comment">// 可以通过 ptr 修改 x 的值</span></span><br><span class="line">ptr = &amp;y;              <span class="comment">// 错误，ptr 是常量，不能指向别的地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>指向 <code>const</code> 对象的 <code>const</code> 指针<br> 结合体了属于是，指针和指向的对象都不能修改：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;x;  <span class="comment">// 常量指针，且指向一个 const 对象</span></span><br><span class="line">*ptr = <span class="number">20</span>;                 <span class="comment">// 错误，不能修改 x 的值</span></span><br><span class="line">ptr = &amp;y;                  <span class="comment">// 错误，不能改变 ptr 指向的地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="1-3-const函数"><a href="#1-3-const函数" class="headerlink" title="1.3 const函数"></a>1.3 const函数</h2><p><code>const</code> 关键字也可以用在成员函数中，用于表示该函数不会修改对象的成员变量。</p>
<h3 id="1-3-1-const-成员函数"><a href="#1-3-1-const-成员函数" class="headerlink" title="1.3.1**const 成员函数**"></a>1.3.1**<code>const</code> 成员函数**</h3><p>成员函数的末尾加上 <code>const</code> 表示该函数不会修改对象的状态。也就是说，函数内部不能改变任何成员变量的值（除非是 <code>mutable</code> 修饰的变量）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;   <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> x;            <span class="comment">// 不能修改类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="1-3-2-const-函数和非-const-函数的重载"><a href="#1-3-2-const-函数和非-const-函数的重载" class="headerlink" title="1.3.2 const 函数和非 const 函数的重载"></a>1.3.2 <strong><code>const</code> 函数和非 <code>const</code> 函数的重载</strong></h3><blockquote>
<p><code>const</code> 版本的函数只能被 <code>const</code> 对象调用，而非 <code>const</code> 版本的函数可以被普通对象调用。</p>
</blockquote>
<p>在一个类中，你可以定义两个具有相同名称但不同 <code>const</code> 限定的成员函数。**<code>const</code> 版本的函数只能被 <code>const</code> 对象调用，而非 <code>const</code> 版本的函数可以被普通对象调用。**</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;  <span class="comment">// 非 const 版本</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;  <span class="comment">// const 版本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    <span class="type">const</span> MyClass obj2;</span><br><span class="line">    </span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">getValue</span>();  <span class="comment">// 调用非 const 版本</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">getValue</span>();  <span class="comment">// 调用 const 版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-const-返回值"><a href="#1-3-3-const-返回值" class="headerlink" title="1.3.3 const 返回值"></a>1.3.3 <strong><code>const</code> 返回值</strong></h3><p>当函数返回一个 <code>const</code> 值时，表示返回的对象是不可修改的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">getValue</span>();</span><br><span class="line">    x = <span class="number">20</span>;  <span class="comment">// 正确，可以修改 x</span></span><br><span class="line">    <span class="built_in">getValue</span>() = <span class="number">20</span>;  <span class="comment">// 错误，不能修改 const 返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-3-4-const-参数"><a href="#1-3-4-const-参数" class="headerlink" title="1.3.4 const 参数"></a>1.3.4 <strong><code>const</code> 参数</strong></h3><p><code>const</code> 参数表示该参数在函数内部不能被修改，通常用于传递引用或指针以提高性能，同时保证函数不会修改参数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// value 不能被修改</span></span><br><span class="line">    std::cout &lt;&lt; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-3-5-函数参数后的-const"><a href="#1-3-5-函数参数后的-const" class="headerlink" title="1.3.5 函数参数后的 const"></a>1.3.5 <strong>函数参数后的 <code>const</code></strong></h3><p>表示该成员函数不会修改类的成员变量。通常用于成员函数，表明该函数不会改变对象的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  <span class="comment">// const 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-Operator-overloading"><a href="#2-Operator-overloading" class="headerlink" title="2.Operator overloading"></a>2.Operator overloading</h1><p>我们有很多的操作符，其中差不多有40多种可以被重载，就是下图中标黄的部分<img src="https://gitee.com/salianbooth/picture/raw/master/202409161707187.png" alt="Clip_2024-09-16_17-07-41.png"></p>
<h2 id="2-1重载"><a href="#2-1重载" class="headerlink" title="2.1重载&lt;&lt; &amp; &gt;&gt;"></a>2.1重载&lt;&lt; &amp; &gt;&gt;</h2><p>这一部分在<a href="https://salianbooth.github.io/2024/08/02/C-Primer-learning/">C++Primer</a>中也有详细的讲过，这里就简单举一个例子，<br>这一部分在之前写图书管理系统有用过，但是当时还是一知半解，借助chatgpt才完成的。C++标准库提供了 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符用于输出和输入操作，这些运算符的默认行为只适用于标准数据类型，例如整数、浮点数、字符串等。但对于自定义的类或结构体，我们可以通过重载这两个运算符来实现输入输出的功能。<br><em><strong>重载输出运算符</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  </span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,<span class="type">const</span> A&amp;);  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">int</span> a_;  </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a_</span>(<span class="number">0</span>) &#123;&#125;  </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : <span class="built_in">a_</span>(a) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在类内会有一个隐式的绑定，lhs就是this的A  </span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>+ (<span class="type">const</span> A&amp; a)&#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in operator + &quot;</span> &lt;&lt; a.a_ &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">this</span>-&gt;a_ += a.a_;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//在&lt;&lt;这个operator上就不能隐式绑定了，因为第一个是ostream，并且它也不能拷贝  </span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> A&amp; a)&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in operator &lt;&lt; &quot;</span> &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    os &lt;&lt; a.a_ &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span>  os;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;  </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><strong>重载输入运算符</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &gt;&gt; 运算符</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream &amp;in, Person &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入运算符重载的定义</span></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream &amp;in, Person &amp;p) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter name: &quot;</span>;</span><br><span class="line">    in &gt;&gt; p.name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter age: &quot;</span>;</span><br><span class="line">    in &gt;&gt; p.age;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    std::cin &gt;&gt; person;</span><br><span class="line">    std::cout &lt;&lt; person &lt;&lt; std::endl; <span class="comment">// 输出输入的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-POLA"><a href="#2-2-POLA" class="headerlink" title="2.2 POLA"></a>2.2 POLA</h2><p>在 C++ 和软件设计的背景下，<strong>POLA</strong> 是 “Principle of Least Astonishment”（最小惊讶原则）的缩写。这一原则也被称为<strong>最小惊讶原则</strong>或<strong>最小意外原则</strong>，它主张设计系统时，应该遵循用户或程序员的直觉，避免让他们感到意外或困惑。</p>
<h3 id="1-POLA-的基本概念"><a href="#1-POLA-的基本概念" class="headerlink" title="1. POLA 的基本概念"></a>1. <strong>POLA 的基本概念</strong></h3><p>POLA 的核心思想是：<strong>代码、接口、或库的行为应该符合用户的期望</strong>，从而避免在使用时出现惊讶或意外的结果。这一原则在编写代码时很有用，因为它能提高代码的可读性、可维护性，并减少出错的几率。</p>
<h3 id="2-POLA-在-C-编程中的应用"><a href="#2-POLA-在-C-编程中的应用" class="headerlink" title="2. POLA 在 C++ 编程中的应用"></a>2. <strong>POLA 在 C++ 编程中的应用</strong></h3><p>在 C++ 中，POLA 可以在多个层面上应用，涵盖代码设计、库设计、函数行为等，以下是几个常见场景：</p>
<h4 id="2-1-函数和运算符的预期行为"><a href="#2-1-函数和运算符的预期行为" class="headerlink" title="2.1 函数和运算符的预期行为"></a>2.1 <strong>函数和运算符的预期行为</strong></h4><p>在重载运算符或函数时，必须遵循 POLA，使得用户直观地理解它们的行为。例如：</p>
<ul>
<li><p>如果重载 <code>+</code> 运算符，用户通常会期望它是相加操作，而不是减法或其他操作。如果行为与标准运算符不一致，会让用户感到意外。</p>
</li>
<li><p>构造函数应该初始化类的成员，并确保类的对象在构造后处于有效的状态。如果构造函数不进行适当的初始化，用户可能会感到意外。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 按照 POLA 原则，这里应初始化所有成员变量</span></span><br><span class="line">        <span class="comment">// 避免未定义行为或令人意外的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-接口设计"><a href="#2-2-接口设计" class="headerlink" title="2.2 接口设计"></a>2.2 <strong>接口设计</strong></h4><p>设计类和函数的接口时，也需要遵循 POLA。例如：</p>
<ul>
<li><p><strong>函数的返回值</strong>：用户调用一个函数时，通常期待返回值与函数名相关。例如，一个名为 <code>getValue()</code> 的函数，用户会期望它返回某个值，而不是修改对象的内部状态。</p>
</li>
<li><p><strong>合理的默认参数</strong>：当函数提供默认参数时，应该保证这些默认参数不会导致意外行为。默认参数应符合常见的使用场景，而不是稀有的边界情况。</p>
</li>
</ul>
<h4 id="2-3-函数副作用"><a href="#2-3-函数副作用" class="headerlink" title="2.3 函数副作用"></a>2.3 <strong>函数副作用</strong></h4><p>函数不应该有未预期的副作用。如果一个函数名表明它是一个查询函数，那么用户通常会期望它不修改任何数据。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按照 POLA 原则，这个函数名表明它是只读操作</span></span><br><span class="line">    <span class="comment">// 它不应该修改类的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-错误处理和异常"><a href="#2-4-错误处理和异常" class="headerlink" title="2.4 错误处理和异常"></a>2.4 <strong>错误处理和异常</strong></h4><p>在错误处理方面，程序设计应该避免让用户意外地收到异常或错误信息。例如：</p>
<ul>
<li><strong>隐式转换</strong>：如果隐式转换可能导致模糊或不明确的行为，那么这种设计不符合 POLA。用户可能期望使用特定类型而不会产生副作用。</li>
<li><strong>合理的异常抛出</strong>：如果函数有可能抛出异常，用户应该能够预测到。否则，程序可能会在用户意外的地方崩溃。</li>
</ul>
<h4 id="2-5-资源管理"><a href="#2-5-资源管理" class="headerlink" title="2.5 资源管理"></a>2.5 <strong>资源管理</strong></h4><p>当使用资源（如内存、文件句柄）时，用户期望资源能够自动释放，因此应该遵循 RAII（Resource Acquisition Is Initialization）原则，避免内存泄漏和资源未正确释放的情况。</p>
<p>例如，在 C++ 中使用智能指针可以更符合 POLA，因为它自动管理资源，避免用户意外忘记释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 用户不需要担心手动释放内存，符合 POLA</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-函数和类的命名"><a href="#2-6-函数和类的命名" class="headerlink" title="2.6 函数和类的命名"></a>2.6 <strong>函数和类的命名</strong></h4><p>良好的命名能够帮助遵循 POLA。函数、变量和类的名称应该清晰地表达它们的意图。用户通过名称应该能够推测出它们的功能，避免意外误用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserAccount</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">authenticate</span><span class="params">()</span></span>;   <span class="comment">// 名称清晰表明此函数用于身份验证</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-POLA-的重要性"><a href="#3-POLA-的重要性" class="headerlink" title="3. POLA 的重要性"></a>3. <strong>POLA 的重要性</strong></h3><ul>
<li><strong>提高可读性和可维护性</strong>：遵循 POLA 的代码更容易理解和维护，因为它的行为是直观的，符合程序员的期望。</li>
<li><strong>减少 Bug 和错误</strong>：用户意外的行为往往会导致 Bug。如果程序的行为总是符合预期，用户就能更容易理解并正确使用代码，减少出错的机会。</li>
<li><strong>提高用户体验</strong>：对于开发库或 API 的开发者来说，遵循 POLA 能让使用者更愉快地使用接口，不需要反复查阅文档来确认每个函数的行为。</li>
</ul>
<h1 id="3-Member-Function"><a href="#3-Member-Function" class="headerlink" title="3.Member Function"></a>3.Member Function</h1><h2 id="3-1-copy-constructor-copy-assignment"><a href="#3-1-copy-constructor-copy-assignment" class="headerlink" title="3.1 copy constructor &amp; copy assignment"></a>3.1 copy constructor &amp; copy assignment</h2><p>在 C++ 中，<strong>拷贝构造函数</strong>（copy constructor）和<strong>拷贝赋值运算符</strong>（copy assignment operator）都用于复制对象，但它们在应用场景和行为上有所不同。以下是两者的主要区别和详细解释：</p>
<h3 id="1-拷贝构造函数（Copy-Constructor）"><a href="#1-拷贝构造函数（Copy-Constructor）" class="headerlink" title="1. 拷贝构造函数（Copy Constructor）"></a>1. <strong>拷贝构造函数（Copy Constructor）</strong></h3><ul>
<li><p><strong>定义</strong>：拷贝构造函数是在创建一个新的对象时，通过已有对象来初始化新对象的构造函数。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>何时调用</strong>：拷贝构造函数在以下几种情况中调用：</p>
<ol>
<li>当用现有对象初始化一个新的对象时：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj1;      <span class="comment">// 调用默认构造函数</span></span><br><span class="line">ClassName obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li>
<li>当函数通过值传递对象时：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(ClassName obj)</span></span>; <span class="comment">// 在调用 func 时，会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li>
<li>当函数返回对象时（通过值返回）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ClassName <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassName obj;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 拷贝构造函数可能被调用，或是启用返回值优化（RVO）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>默认行为</strong>：如果不显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，它会按<strong>成员逐一拷贝</strong>的方式（shallow copy）复制对象的成员。</p>
</li>
<li><p><strong>自定义拷贝构造函数</strong>：在对象有需要深拷贝的资源（如动态分配的内存、文件句柄等）时，往往需要显式定义拷贝构造函数来避免浅拷贝带来的问题。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (深拷贝)</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-拷贝赋值运算符（Copy-Assignment-Operator）"><a href="#2-拷贝赋值运算符（Copy-Assignment-Operator）" class="headerlink" title="2. 拷贝赋值运算符（Copy Assignment Operator）"></a>2. <strong>拷贝赋值运算符（Copy Assignment Operator）</strong></h3><ul>
<li><p><strong>定义</strong>：拷贝赋值运算符用于将一个对象的内容赋值给另一个已经存在的对象。它不同于拷贝构造函数，它是修改已有对象而不是创建新对象。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ClassName&amp; other);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>何时调用</strong>：拷贝赋值运算符在对象已经被创建且需要被重新赋值时调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj1; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">ClassName obj2; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">obj2 = obj1;    <span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认行为</strong>：如果不显式定义拷贝赋值运算符，编译器会自动生成一个默认的拷贝赋值运算符，按<strong>成员逐一赋值</strong>的方式（shallow copy）进行赋值。</p>
</li>
<li><p><strong>自定义拷贝赋值运算符</strong>：在类管理动态资源时，需要自定义拷贝赋值运算符，以避免浅拷贝问题，并且需要小心处理自赋值的情况（如 <code>a = a;</code>），以避免资源被不正确地释放。</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;      <span class="comment">// 检查自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> data;           <span class="comment">// 释放旧内存</span></span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-区别总结"><a href="#3-区别总结" class="headerlink" title="3. 区别总结"></a>3. <strong>区别总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>拷贝构造函数</th>
<th>拷贝赋值运算符</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>用一个已有对象创建一个新对象</td>
<td>将一个已有对象的内容赋值给另一个已存在的对象</td>
</tr>
<tr>
<td><strong>调用时机</strong></td>
<td>当新对象被创建并需要初始化时（如传递值参数、返回值）</td>
<td>当一个已有对象需要被重新赋值时</td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td><code>ClassName(const ClassName&amp; other)</code></td>
<td><code>ClassName&amp; operator=(const ClassName&amp; other)</code></td>
</tr>
<tr>
<td><strong>默认行为</strong></td>
<td>默认按成员逐一拷贝</td>
<td>默认按成员逐一赋值</td>
</tr>
<tr>
<td><strong>自赋值检查</strong>（<code>a = a</code>）</td>
<td>不需要（新对象和原对象不同）</td>
<td>通常需要进行自赋值检查</td>
</tr>
<tr>
<td><strong>返回类型</strong></td>
<td>不返回值</td>
<td>返回当前对象的引用 (<code>*this</code>)</td>
</tr>
</tbody></table>
<h3 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. <strong>使用示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy Constructor called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 检查自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> data;       <span class="comment">// 释放旧内存</span></span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy Assignment Operator called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 构造函数</span></span><br><span class="line">    MyClass obj2 = obj1;      <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(<span class="number">20</span>)</span></span>;         <span class="comment">// 构造函数</span></span><br><span class="line">    obj3 = obj1;              <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li><strong>拷贝构造函数</strong>用于创建新对象，并用已有对象来初始化它。</li>
<li><strong>拷贝赋值运算符</strong>用于将一个对象的内容赋值给已经存在的另一个对象。</li>
</ul>
<p>理解它们的区别，尤其是在涉及到管理动态资源时，至关重要。通过定义深拷贝机制，确保对象之间的复制操作不会产生意外的共享资源或内存泄漏问题。</p>
<h2 id="3-2-move-constructor-move-assignment"><a href="#3-2-move-constructor-move-assignment" class="headerlink" title="3.2 move constructor &amp; move assignment"></a>3.2 move constructor &amp; move assignment</h2><p><strong>移动构造函数</strong>和<strong>移动赋值运算符（Move Assignment Operator）</strong>都是 C++11 引入的特性，用于优化对象的移动操作，避免不必要的深拷贝。它们在语法、调用场景和使用上存在一些重要区别。</p>
<h3 id="1-移动构造函数（Move-Constructor）"><a href="#1-移动构造函数（Move-Constructor）" class="headerlink" title="1. 移动构造函数（Move Constructor）"></a>1. <strong>移动构造函数（Move Constructor）</strong></h3><ul>
<li><p><strong>定义</strong>：移动构造函数用于创建一个新对象，并通过“移动”资源而非“复制”资源的方式来初始化新对象。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ClassName</span>(ClassName&amp;&amp; other);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用时机</strong>：移动构造函数在以下情况下调用：</p>
<ol>
<li>当一个临时对象（右值）被用来初始化另一个对象时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj1 = std::<span class="built_in">move</span>(temp_obj); <span class="comment">// 移动构造函数被调用</span></span><br></pre></td></tr></table></figure></li>
<li>当函数返回一个对象，并且启用了移动语义时。</li>
<li>在某些容器（如 <code>std::vector</code>）重分配内存并移动其元素时。</li>
</ol>
</li>
<li><p><strong>作用</strong>：移动构造函数将源对象（通常是临时对象）的资源（如指针、文件句柄等）“移动”到新对象中，而不是复制资源。移动后，源对象处于有效但未定义的状态，通常会将其内部指针设为 <code>nullptr</code>，防止资源重复释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data = other.data;   <span class="comment">// 直接获取资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 清空源对象的资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-移动赋值运算符（Move-Assignment-Operator）"><a href="#2-移动赋值运算符（Move-Assignment-Operator）" class="headerlink" title="2. 移动赋值运算符（Move Assignment Operator）"></a>2. <strong>移动赋值运算符（Move Assignment Operator）</strong></h3><ul>
<li><p><strong>定义</strong>：移动赋值运算符用于将一个已有对象的资源“移动”到另一个已经存在的对象上。这与移动构造函数的区别在于，移动赋值是针对已经存在的对象，而移动构造是创建新对象。</p>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; <span class="keyword">operator</span>=(ClassName&amp;&amp; other);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用时机</strong>：移动赋值运算符在以下情况下调用：</p>
<ol>
<li>当一个临时对象（右值）被赋值给一个已经存在的对象时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj1;</span><br><span class="line">obj1 = std::<span class="built_in">move</span>(temp_obj); <span class="comment">// 移动赋值运算符被调用</span></span><br></pre></td></tr></table></figure></li>
<li>当一个对象从另一个对象中通过移动语义赋值时。</li>
</ol>
</li>
<li><p><strong>作用</strong>：移动赋值运算符用于释放目标对象的现有资源（如果有的话），然后“移动”源对象的资源到目标对象中。与移动构造函数不同的是，移动赋值运算符需要处理目标对象已经分配了资源的情况，通常需要先释放旧资源以避免内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;      <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> data;           <span class="comment">// 释放旧资源</span></span><br><span class="line">            data = other.data;     <span class="comment">// 获取新资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;  <span class="comment">// 清空源对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-移动构造函数和移动赋值运算符的区别"><a href="#3-移动构造函数和移动赋值运算符的区别" class="headerlink" title="3. 移动构造函数和移动赋值运算符的区别"></a>3. <strong>移动构造函数和移动赋值运算符的区别</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>移动构造函数</strong></th>
<th><strong>移动赋值运算符</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目标</strong></td>
<td>创建一个新对象并移动资源</td>
<td>将资源从一个对象“移动”到已经存在的对象中</td>
</tr>
<tr>
<td><strong>调用时机</strong></td>
<td>当新对象通过右值初始化时</td>
<td>当已有对象通过右值被赋值时</td>
</tr>
<tr>
<td><strong>语法</strong></td>
<td><code>ClassName(ClassName&amp;&amp; other)</code></td>
<td><code>ClassName&amp; operator=(ClassName&amp;&amp; other)</code></td>
</tr>
<tr>
<td><strong>需要处理的资源状态</strong></td>
<td>新对象刚创建，没有已有资源</td>
<td>已有对象可能已经持有资源，需要先清理或释放</td>
</tr>
<tr>
<td><strong>是否涉及自赋值检查</strong></td>
<td>不需要，因为是构造新对象</td>
<td>需要检查自赋值，以避免错误释放资源</td>
</tr>
<tr>
<td><strong>示例场景</strong></td>
<td>用临时对象初始化新对象</td>
<td>将一个对象通过移动语义赋值给另一个已有对象</td>
</tr>
</tbody></table>
<h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. <strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data = other.data;         <span class="comment">// 直接获取资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;      <span class="comment">// 清空源对象</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;      <span class="comment">// 检查自赋值</span></span><br><span class="line">            <span class="keyword">delete</span> data;           <span class="comment">// 释放现有资源</span></span><br><span class="line">            data = other.data;     <span class="comment">// 获取新资源</span></span><br><span class="line">            other.data = <span class="literal">nullptr</span>;  <span class="comment">// 清空源对象</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move Assignment Operator called\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;              <span class="comment">// 构造函数</span></span><br><span class="line">    MyClass obj2 = std::<span class="built_in">move</span>(obj1); <span class="comment">// 移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(<span class="number">20</span>)</span></span>;              <span class="comment">// 构造函数</span></span><br><span class="line">    obj3 = std::<span class="built_in">move</span>(obj2);        <span class="comment">// 移动赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li><strong>移动构造函数</strong>：用于通过“移动”资源来创建一个新对象，避免不必要的复制操作。适用于初始化新对象时。</li>
<li><strong>移动赋值运算符</strong>：用于将已有对象的资源“移动”到另一个已存在的对象上，适用于赋值操作。</li>
</ul>
<p>移动构造函数与移动赋值运算符的主要区别在于它们的应用场景和作用的对象不同。前者是在创建新对象时调用，后者是在对象赋值时调用。</p>
<h2 id="3-3-rvalue-lvalue"><a href="#3-3-rvalue-lvalue" class="headerlink" title="3.3 rvalue &amp; lvalue"></a>3.3 rvalue &amp; lvalue</h2><p>在 C++ 中，<strong>左值（Lvalue）</strong> 和 <strong>右值（Rvalue）</strong> 是用来描述表达式值的两类概念，主要用于区分表达式在赋值、函数调用等场景中的行为方式。理解这两者的区别对于掌握 C++ 的赋值、函数重载、移动语义等特性非常重要。</p>
<h3 id="1-Lvalue（左值）"><a href="#1-Lvalue（左值）" class="headerlink" title="1. Lvalue（左值）"></a>1. <strong>Lvalue（左值）</strong></h3><ul>
<li><p><strong>定义</strong>：Lvalue 是指<strong>有明确内存地址</strong>的表达式，可以在程序的多个地方被引用。左值通常是可以出现在赋值表达式左边的值，因此可以被修改。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>Lvalue 表示持久存在的对象（具有内存地址）。</li>
<li>可以出现在赋值运算符的左侧和右侧（即可以读取和修改）。</li>
<li>是可以被取地址的，使用 <code>&amp;</code> 可以获取它的地址。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;   <span class="comment">// 变量 x 是一个左值</span></span><br><span class="line">x = <span class="number">20</span>;       <span class="comment">// 可以给 x 赋值，x 是一个左值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;x;  <span class="comment">// 可以通过取地址符获取 x 的地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结</strong>：Lvalue 是指向某个内存位置的对象或表达式，表示可以被引用和修改的值。</p>
</li>
</ul>
<h3 id="2-Rvalue（右值）"><a href="#2-Rvalue（右值）" class="headerlink" title="2. Rvalue（右值）"></a>2. <strong>Rvalue（右值）</strong></h3><ul>
<li><p><strong>定义</strong>：Rvalue 是指<strong>不占有内存地址</strong>或者<strong>临时的值</strong>，它只能出现在赋值运算符的右侧。Rvalue 通常是一些临时对象，它们的生命周期仅限于当前表达式。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>Rvalue 表示临时的值，通常是不能取地址的（因为它们没有持久的内存地址）。</li>
<li>不能出现在赋值运算符的左侧，意味着它们不能被修改。</li>
<li>右值通常包括字面量（如整数、浮点数等）和临时对象。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span>;    <span class="comment">// 5 是一个右值（它是一个字面量）</span></span><br><span class="line">y = x + <span class="number">10</span>;   <span class="comment">// x + 10 是一个右值（表达式结果是临时值）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结</strong>：Rvalue 是指一个临时值或表达式的计算结果，不会持久存在，也不能被修改或取地址。</p>
</li>
</ul>
<h3 id="3-Lvalue-和-Rvalue-的区别"><a href="#3-Lvalue-和-Rvalue-的区别" class="headerlink" title="3. Lvalue 和 Rvalue 的区别"></a>3. <strong>Lvalue 和 Rvalue 的区别</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Lvalue</strong></th>
<th><strong>Rvalue</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储</strong></td>
<td>有明确的内存地址（持久的对象）</td>
<td>临时的，没有内存地址（短暂的值）</td>
</tr>
<tr>
<td><strong>赋值</strong></td>
<td>可以出现在赋值操作的左侧和右侧</td>
<td>只能出现在赋值操作的右侧</td>
</tr>
<tr>
<td><strong>取地址</strong></td>
<td>可以取地址 (<code>&amp;</code>)</td>
<td>不能取地址</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>在作用域中持久存在</td>
<td>临时的，仅在当前表达式中有效</td>
</tr>
</tbody></table>
<h3 id="4-右值引用（Rvalue-Reference）与左值引用（Lvalue-Reference）"><a href="#4-右值引用（Rvalue-Reference）与左值引用（Lvalue-Reference）" class="headerlink" title="4. 右值引用（Rvalue Reference）与左值引用（Lvalue Reference）"></a>4. <strong>右值引用（Rvalue Reference）与左值引用（Lvalue Reference）</strong></h3><p>C++11 引入了 <strong>右值引用（Rvalue Reference）</strong> 的概念，以优化对象的移动操作和减少不必要的复制。</p>
<h4 id="左值引用（Lvalue-Reference）："><a href="#左值引用（Lvalue-Reference）：" class="headerlink" title="左值引用（Lvalue Reference）："></a><strong>左值引用（Lvalue Reference）</strong>：</h4><ul>
<li>左值引用是引用左值对象的引用。</li>
<li>语法：<code>Type&amp; ref = lvalue;</code></li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = x; <span class="comment">// ref 是 x 的左值引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="右值引用（Rvalue-Reference）："><a href="#右值引用（Rvalue-Reference）：" class="headerlink" title="右值引用（Rvalue Reference）："></a><strong>右值引用（Rvalue Reference）</strong>：</h4><ul>
<li>右值引用是引用右值对象的引用，通常用于捕获临时对象，以便进行“移动语义”操作（如 <code>std::move</code>）。</li>
<li>语法：<code>Type&amp;&amp; ref = rvalue;</code></li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; ref = <span class="number">10</span>; <span class="comment">// ref 是 10 的右值引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-Lvalue-和-Rvalue-示例详解"><a href="#5-Lvalue-和-Rvalue-示例详解" class="headerlink" title="5. Lvalue 和 Rvalue 示例详解"></a>5. <strong>Lvalue 和 Rvalue 示例详解</strong></h3><h4 id="左值示例："><a href="#左值示例：" class="headerlink" title="左值示例："></a>左值示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;      <span class="comment">// x 是左值，有明确内存地址</span></span><br><span class="line"><span class="type">int</span>* p = &amp;x;     <span class="comment">// 可以获取 x 的地址</span></span><br><span class="line">x = <span class="number">100</span>;         <span class="comment">// 左值可以出现在赋值运算符的左侧</span></span><br></pre></td></tr></table></figure>

<h4 id="右值示例："><a href="#右值示例：" class="headerlink" title="右值示例："></a>右值示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = x + <span class="number">10</span>;  <span class="comment">// x + 10 是一个右值，表示表达式的临时结果</span></span><br><span class="line"><span class="type">int</span>* p = &amp;(x + <span class="number">10</span>); <span class="comment">// 错误！不能获取右值的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="6-进一步理解：Lvalue、Rvalue-与函数重载"><a href="#6-进一步理解：Lvalue、Rvalue-与函数重载" class="headerlink" title="6. 进一步理解：Lvalue、Rvalue 与函数重载"></a>6. <strong>进一步理解：Lvalue、Rvalue 与函数重载</strong></h3><p>C++11 中引入的右值引用允许我们根据左值和右值进行函数重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue reference called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue reference called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);           <span class="comment">// 调用左值版本</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);          <span class="comment">// 调用右值版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>func</code> 重载了接受左值引用和右值引用的版本，<code>a</code> 是左值，因此调用左值引用版本；<code>10</code> 是右值，因此调用右值引用版本。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h3><ul>
<li><strong>Lvalue（左值）</strong> 是持有内存地址的对象，具有较长生命周期，可以被修改。</li>
<li><strong>Rvalue（右值）</strong> 是临时的、短暂的值，通常不能被修改或取地址。</li>
<li>C++11 引入了 <strong>右值引用（Rvalue Reference）</strong>，用于捕获右值并实现优化的移动语义。</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="https://gitee.com/salianbooth/picture/raw/master/202409151025446.png" alt="Clip_2024-09-15_10-25-33.png"><br>让我们逐行分析这段代码及其对应的注释。</p>
<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ol>
<li><p><strong>前置变量定义</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* ptr = <span class="number">0x02248837</span>; <span class="comment">// 假设地址为 0x02248837</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val</code> 是一个整数变量，存储值 <code>2</code>。</li>
<li><code>ptr</code> 是一个指向整数的指针，指向一个特定地址（这里用一个示例地址 <code>0x02248837</code> 表示）。</li>
<li><code>v1</code> 是一个包含三个整数的 <code>vector</code>，分别是 <code>1, 2, 3</code>。</li>
</ul>
</li>
<li><p><strong>各个语句分析</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr2 = ptr;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ptr2</code> 是通过 <code>auto</code> 类型推导得到的，类型是 <code>int*</code>（因为 <code>ptr</code> 是 <code>int*</code>）。</li>
<li><code>ptr2</code> 是一个指针，是一个左值（Lvalue）。</li>
<li><strong>注释解释</strong>：<code>ptr2 is an l-value reference</code>。<ul>
<li>这里的注释有点误导，实际上 <code>ptr2</code> 是一个左值变量，而不是左值引用。</li>
<li>它是一个普通指针，指向 <code>ptr</code> 所指向的地址。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; v4 = v1[<span class="number">1</span>] + v2;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>v4</code> 是一个右值引用，<code>auto&amp;&amp;</code> 的类型推导会根据右值表达式来推导出 <code>int&amp;&amp;</code> 类型。</li>
<li><code>v1[1] + v2</code> 是一个右值表达式，因为它的结果是一个临时值。</li>
<li><code>v4</code> 绑定到一个临时右值结果，这就是为什么 <code>v4</code> 是右值引用。</li>
<li><strong>注释解释</strong>：<code>v4 is an r-value reference</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; ptr3 = &amp;val;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&amp;val</code> 是一个右值表达式，它返回一个指针，这里是 <code>int*</code> 类型。</li>
<li>由于 <code>&amp;val</code> 是一个右值，不能绑定到一个左值引用（<code>auto&amp;</code>）。</li>
<li><strong>注释解释</strong>：<code>ERROR: can&#39;t bind l-val ref to r-value</code><ul>
<li>试图将一个左值引用（<code>auto&amp;</code>）绑定到一个右值（<code>&amp;val</code>）上，这是非法的。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; val2 = val;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>val</code> 是一个左值，它可以绑定到一个右值引用（<code>auto&amp;&amp;</code>）上。</li>
<li>这是因为 <code>auto&amp;&amp;</code> 会推导出一个左值引用。</li>
<li><strong>注释解释</strong>：<code>ERROR: can&#39;t bind r-val ref to l-value</code><ul>
<li>这个注释看起来是错误的，因为 <code>auto&amp;&amp;</code> 可以绑定到 <code>val</code>（一个左值）上，这是 C++11 中的完美转发（forwarding references）。</li>
<li>正确的解释应该是：<code>val2</code> 是一个右值引用，但在这种情况下它会被推导为左值引用。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; ptr3 = ptr + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ptr + 5</code> 是一个右值表达式，结果是一个新的指针值。</li>
<li><code>const auto&amp;</code> 可以绑定到右值，这是合法的，因为它是 <code>const</code> 左值引用。</li>
<li><strong>注释解释</strong>：<code>OKAY: CAN bind const l-val ref to r-value (WHY?)</code><ul>
<li>这是因为 <code>const</code> 左值引用可以延长临时对象的生命周期，所以它可以绑定到右值表达式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>左值</strong> 是指对象的内存地址，它们在表达式中可以出现在赋值号左边，可以取地址。</li>
<li><strong>右值</strong> 是没有内存地址的临时对象，通常不能被修改或取地址。</li>
<li><strong>左值引用</strong>（<code>auto&amp;</code>）可以绑定到左值，但不能绑定到右值。</li>
<li><strong>右值引用</strong>（<code>auto&amp;&amp;</code>）可以绑定到右值，可以实现移动语义。</li>
<li><ul>
<li><strong>常量左值引用</strong>（如 <code>const_Lref</code>）可以绑定到<strong>左值</strong>和<strong>右值</strong>，因为它不会修改绑定的对象，并且可以延长临时右值的生命周期。</li>
</ul>
</li>
</ul>
<p><strong>注释中的错误</strong>:</p>
<ul>
<li><code>auto&amp;&amp; val2 = val;</code> 的注释是错误的，因为 <code>auto&amp;&amp;</code> 在这里作为一个万能引用（forwarding reference），它可以绑定到左值 <code>val</code>，并推导出 <code>int&amp;</code> 类型。</li>
</ul>
<h1 id="4-Inherent"><a href="#4-Inherent" class="headerlink" title="4.Inherent"></a>4.Inherent</h1><p>在 C++ 中，<strong>继承</strong>、<strong>虚函数</strong>、<strong>纯虚函数</strong>和<strong>抽象类</strong>是面向对象编程的核心概念，它们用于实现<strong>多态性</strong>，即不同类型的对象可以通过相同的接口进行操作。下面我会详细解释这些概念：</p>
<h3 id="1-继承（Inheritance）"><a href="#1-继承（Inheritance）" class="headerlink" title="1. 继承（Inheritance）"></a>1. <strong>继承（Inheritance）</strong></h3><p>继承是面向对象编程的一个机制，允许一个类从另一个类派生，从而获得父类的属性和方法。子类可以直接使用父类的功能，也可以根据需要进行<strong>重写（override）</strong>。</p>
<ul>
<li><strong>基类（Base class）</strong>：也称为父类或超类，是被继承的类。</li>
<li><strong>派生类（Derived class）</strong>：也称为子类，从基类继承的类。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal eats food.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Dog</code> 类继承了 <code>Animal</code> 类，因此它也拥有 <code>eat()</code> 方法，并且可以定义自己的 <code>bark()</code> 方法。</p>
<h3 id="2-虚函数（Virtual-Function）"><a href="#2-虚函数（Virtual-Function）" class="headerlink" title="2. 虚函数（Virtual Function）"></a>2. <strong>虚函数（Virtual Function）</strong></h3><p>虚函数是指在基类中声明的函数，旨在通过<strong>指针或引用</strong>在运行时实现<strong>多态性</strong>。通过在基类中使用 <code>virtual</code> 关键字修饰函数，派生类可以重写该函数，并且在运行时会根据对象的实际类型调用合适的版本。</p>
<h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes sound.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 重写基类的虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基类</strong> <code>Animal</code> 定义了一个虚函数 <code>makeSound()</code>。</li>
<li><strong>派生类</strong> <code>Dog</code> 重写了这个虚函数。</li>
<li>通过基类指针调用时，会根据指向的对象类型调用相应的版本（即使该指针类型是基类）。</li>
</ul>
<h4 id="多态性示例："><a href="#多态性示例：" class="headerlink" title="多态性示例："></a>多态性示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">animal-&gt;<span class="built_in">makeSound</span>();  <span class="comment">// 输出：Dog barks.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然 <code>animal</code> 是 <code>Animal*</code> 类型，但它指向的是一个 <code>Dog</code> 对象，因此会调用 <code>Dog</code> 类的 <code>makeSound()</code> 函数，而不是 <code>Animal</code> 类的版本。</li>
</ul>
<h3 id="3-纯虚函数（Pure-Virtual-Function）"><a href="#3-纯虚函数（Pure-Virtual-Function）" class="headerlink" title="3. 纯虚函数（Pure Virtual Function）"></a>3. <strong>纯虚函数（Pure Virtual Function）</strong></h3><p>纯虚函数是没有实现的虚函数。一个包含纯虚函数的类是<strong>抽象类</strong>，不能直接实例化。纯虚函数的声明通过在函数签名后面添加 <code>= 0</code> 来实现。</p>
<h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Animal</code> 类中 <code>makeSound()</code> 函数是纯虚函数，这意味着派生类必须<strong>实现</strong>它，否则派生类也将成为抽象类。</li>
<li>如果某个派生类没有实现所有纯虚函数，则该派生类也是抽象类，不能被实例化。</li>
</ul>
<h3 id="4-抽象类（Abstract-Class）"><a href="#4-抽象类（Abstract-Class）" class="headerlink" title="4. 抽象类（Abstract Class）"></a>4. <strong>抽象类（Abstract Class）</strong></h3><p>抽象类是指包含一个或多个纯虚函数的类。抽象类不能直接实例化，只能通过继承并实现所有纯虚函数后才能创建派生类的对象。</p>
<h4 id="例子：-3"><a href="#例子：-3" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;    <span class="comment">// 实现纯虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>Animal</code> 类是抽象类</strong>，因为它包含一个纯虚函数 <code>makeSound()</code>。</li>
<li><strong><code>Dog</code> 类是具体类</strong>，因为它实现了 <code>Animal</code> 类的纯虚函数。</li>
<li><code>Animal</code> 不能被实例化，而 <code>Dog</code> 可以被实例化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 可以通过多态实现</span></span><br><span class="line">animal-&gt;<span class="built_in">makeSound</span>();  <span class="comment">// 输出：Dog barks.</span></span><br></pre></td></tr></table></figure>

<h3 id="5-虚函数与纯虚函数的区别"><a href="#5-虚函数与纯虚函数的区别" class="headerlink" title="5. 虚函数与纯虚函数的区别"></a>5. <strong>虚函数与纯虚函数的区别</strong></h3><ul>
<li><strong>虚函数</strong>：基类中有默认的实现，派生类可以选择重写，也可以使用基类的实现。</li>
<li><strong>纯虚函数</strong>：基类中没有实现，派生类必须提供自己的实现。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><ul>
<li><strong>继承</strong>允许子类获得父类的属性和方法。</li>
<li><strong>虚函数</strong>通过指针或引用实现了<strong>运行时多态</strong>，派生类可以重写虚函数。</li>
<li><strong>纯虚函数</strong>是没有实现的虚函数，基类定义接口，派生类必须实现。</li>
<li><strong>抽象类</strong>包含纯虚函数，不能直接实例化，用于定义接口或基础功能。</li>
</ul>
<p>这些概念共同构成了 C++ 中的面向对象编程，特别是在实现多态性和代码复用方面。</p>
<h1 id="5-namespace"><a href="#5-namespace" class="headerlink" title="5.namespace"></a>5.namespace</h1><p>当然可以！关于命名空间（<strong>namespace</strong>）和命名冲突的概念在 C++ 中是非常重要的，尤其是在大型项目或者使用外部库时。通过命名空间，我们可以避免不同代码单元之间出现函数、变量或类名相同的情况。以下是与命名空间和命名冲突相关的知识点：</p>
<h3 id="1-命名空间（namespace）"><a href="#1-命名空间（namespace）" class="headerlink" title="1. 命名空间（namespace）"></a>1. <strong>命名空间（namespace）</strong></h3><p>命名空间是一种<strong>逻辑上划分代码</strong>的方法，用于将一组代码封装在一个特定的命名空间中，防止与其他命名空间或全局作用域中的名称冲突。通过使用命名空间，可以在不同模块或库中使用相同的名称而不会引起冲突。</p>
<h4 id="定义和使用："><a href="#定义和使用：" class="headerlink" title="定义和使用："></a>定义和使用：</h4><p>命名空间通过关键字 <code>namespace</code> 来声明，其语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="comment">// 在命名空间中的代码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用命名空间中的元素，可以通过<strong>作用域解析运算符</strong> <code>::</code> 来访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = MyNamespace::<span class="built_in">myFunction</span>();</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lecture &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ++ctr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，<code>Lecture::count</code> 函数定义在 <code>Lecture</code> 命名空间中，这样就可以和其他同名的 <code>count</code> 函数（例如标准库中的 <code>std::count</code>）区分开来。</p>
<h3 id="2-命名冲突"><a href="#2-命名冲突" class="headerlink" title="2. 命名冲突"></a>2. <strong>命名冲突</strong></h3><p>命名冲突是指在同一个作用域内定义了多个相同名字的实体（例如函数、变量、类等）。在 C++ 中，如果没有使用命名空间进行区分，不同的库、模块或代码可能会定义相同名称的函数或变量，这会导致冲突，编译器无法知道该调用哪个函数或使用哪个变量。</p>
<h4 id="命名冲突的例子："><a href="#命名冲突的例子：" class="headerlink" title="命名冲突的例子："></a>命名冲突的例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 调用标准库的 count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            ++ctr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ctr; <span class="comment">// 自定义的 count 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们定义了两个 <code>count</code> 函数而没有使用命名空间，编译器将不知道该选择哪个 <code>count</code> 函数来调用，导致编译错误。</p>
<h3 id="3-如何避免命名冲突"><a href="#3-如何避免命名冲突" class="headerlink" title="3. 如何避免命名冲突"></a>3. <strong>如何避免命名冲突</strong></h3><p>C++ 提供了几种避免命名冲突的方法，最常见的就是使用<strong>命名空间</strong>。</p>
<h4 id="使用命名空间避免冲突："><a href="#使用命名空间避免冲突：" class="headerlink" title="使用命名空间避免冲突："></a>使用命名空间避免冲突：</h4><p>将可能导致冲突的代码置于不同的命名空间中，便可以清晰地分隔不同模块的代码，防止名称冲突。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyLibrary &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ++ctr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，即使其他地方有同名的 <code>count</code> 函数，只要使用 <code>MyLibrary::count</code>，就不会有冲突。</p>
<h3 id="4-命名空间的嵌套"><a href="#4-命名空间的嵌套" class="headerlink" title="4. 命名空间的嵌套"></a>4. <strong>命名空间的嵌套</strong></h3><p>命名空间可以嵌套，以便进一步组织代码。例如，你可以将某个库的所有组件放在一个顶级命名空间下，然后根据模块进一步细分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Library &#123;</span><br><span class="line">    <span class="keyword">namespace</span> Math &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> Utils &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用时，可以通过完整路径访问嵌套命名空间中的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = Library::Math::<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-using-声明"><a href="#5-using-声明" class="headerlink" title="5. using 声明"></a>5. <strong><code>using</code> 声明</strong></h3><p>在某些情况下，我们希望简化命名空间的使用，可以通过 <code>using</code> 关键字将命名空间引入当前作用域。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>引入后，可以直接使用标准库中的函数和类型，而无需每次使用 <code>std::</code> 前缀。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 不需要 std::vector</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 不需要 std::cout</span></span><br></pre></td></tr></table></figure>

<p>然而，<strong>不推荐</strong>在全局作用域中使用 <code>using namespace</code>，尤其是在大型项目中，因为这会增加命名冲突的风险。较好的做法是仅在<strong>局部作用域</strong>中使用，或者直接为特定的类型或函数使用 <code>using</code> 声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>

<h3 id="6-标准库中的命名空间：std"><a href="#6-标准库中的命名空间：std" class="headerlink" title="6. 标准库中的命名空间：std"></a>6. <strong>标准库中的命名空间：<code>std</code></strong></h3><p>C++ 标准库的所有内容都被封装在 <code>std</code> 命名空间中，例如 <code>std::cout</code>、<code>std::vector</code>、<code>std::string</code> 等。这是为了防止标准库的名称与用户自定义的名称发生冲突。如果 C++ 标准库没有使用命名空间，则像 <code>cout</code>、<code>string</code> 这样的常见名称会很容易与用户代码中的名字冲突。</p>
<p>例如，以下是标准库的命名空间使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-匿名命名空间"><a href="#7-匿名命名空间" class="headerlink" title="7. 匿名命名空间"></a>7. <strong>匿名命名空间</strong></h3><p>在某些情况下，我们希望某个命名空间中的内容只在特定的翻译单元内可见。匿名命名空间（<code>namespace &#123;&#125;</code>）可以实现这种目的，其作用相当于在 C 中使用 <code>static</code> 关键字来限制函数或变量的可见性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helperFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>helperFunction</code> 只能在其定义所在的源文件中使用，其他文件不能访问它。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>命名空间（namespace）</strong>用于组织代码，避免名称冲突。</li>
<li><strong>命名冲突</strong>发生在两个相同名称的实体在同一个作用域中被定义，导致编译错误。</li>
<li>通过<strong>命名空间</strong>可以将代码划分成不同的逻辑单元，避免冲突，增强代码的可读性和可维护性。</li>
<li><strong><code>using</code> 声明</strong>可以简化命名空间的使用，但需谨慎，特别是在全局作用域中。</li>
<li>C++ 标准库使用 <code>std</code> 命名空间，避免了常见名称的冲突。</li>
</ul>
<p>命名空间是一个强大的工具，特别是在大型项目中，可以帮助你有效管理代码结构，避免复杂的命名冲突问题。</p>
<h1 id="6-Extended-Discussion"><a href="#6-Extended-Discussion" class="headerlink" title="6.Extended Discussion"></a>6.Extended Discussion</h1><p>在C++20中引入了<strong>Concepts（概念）</strong>和<strong>Constraints（约束）</strong>，用于对模板参数进行约束和检查，帮助编译器更早发现模板代码中的错误，并让代码更具可读性和表达能力。</p>
<h3 id="1-Concepts（概念）"><a href="#1-Concepts（概念）" class="headerlink" title="1. Concepts（概念）"></a>1. <strong>Concepts（概念）</strong></h3><p>Concepts 是用于定义模板参数必须满足的条件或属性。例如，要求某个模板参数必须是整数类型、浮点数类型，或支持某些操作（如加法、比较等）。</p>
<h4 id="例子：定义一个简单的-Concept"><a href="#例子：定义一个简单的-Concept" class="headerlink" title="例子：定义一个简单的 Concept"></a>例子：定义一个简单的 Concept</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个概念，要求类型 T 是整型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>这个 <code>Integral</code> 概念确保模板参数 <code>T</code> 是一个整型类型。</p>
<h4 id="使用-Concept"><a href="#使用-Concept" class="headerlink" title="使用 Concept"></a>使用 Concept</h4><p>你可以用 Concepts 来约束模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用概念约束模板函数，只允许整型类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;Integral T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">5.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">add</span>(x, y);  <span class="comment">// 正确，x 和 y 是整数</span></span><br><span class="line">    <span class="comment">// add(d, d);  // 编译错误，d 是浮点数，不满足 Integral 概念</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，模板函数 <code>add</code> 被 <code>Integral</code> 概念约束，意味着它只能接受整型参数。这样可以避免某些类型不支持的操作导致的编译错误。</p>
<h4 id="常见-Concepts"><a href="#常见-Concepts" class="headerlink" title="常见 Concepts"></a>常见 Concepts</h4><p>C++20 标准库中还提供了一些常用的概念，例如：</p>
<ul>
<li><code>std::integral</code>：整数类型。</li>
<li><code>std::floating_point</code>：浮点类型。</li>
<li><code>std::default_initializable</code>：能够默认初始化的类型。</li>
<li><code>std::assignable_from</code>：能够赋值的类型。</li>
</ul>
<h3 id="2-Constraints（约束）"><a href="#2-Constraints（约束）" class="headerlink" title="2. Constraints（约束）"></a>2. <strong>Constraints（约束）</strong></h3><p>Constraints 是基于 Concepts 应用在模板参数上的具体限制，通常通过 <code>requires</code> 关键字来实现。Constraints 让你能够更加灵活地控制模板实例化的条件。</p>
<h4 id="例子：使用-Constraints"><a href="#例子：使用-Constraints" class="headerlink" title="例子：使用 Constraints"></a>例子：使用 Constraints</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要两个类型能够相加</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::integral&lt;T&gt;  <span class="comment">// 限制 T 必须是整型</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>requires</code> 表达式用于对模板函数 <code>add</code> 进行约束，确保参数类型 <code>T</code> 必须是 <code>std::integral</code>（即整数类型）。</p>
<h4 id="requires-表达式"><a href="#requires-表达式" class="headerlink" title="requires 表达式"></a>requires 表达式</h4><p><code>requires</code> 关键字用于声明某种约束。你可以用 <code>requires</code> 直接描述条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求 T 支持 + 操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    a + b;  <span class="comment">// 约束：T 类型必须支持 + 操作符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>requires</code> 表达式确保类型 <code>T</code> 支持加法操作。</p>
<h3 id="3-Concepts-vs-Constraints-的关系"><a href="#3-Concepts-vs-Constraints-的关系" class="headerlink" title="3. Concepts vs Constraints 的关系"></a>3. <strong>Concepts vs Constraints 的关系</strong></h3><ul>
<li><strong>Concepts</strong> 是对类型性质的抽象描述，类似于一种“类型检查”机制。</li>
<li><strong>Constraints</strong> 则是使用这些概念来限制模板参数的实际条件。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Concepts</strong> 是对模板参数的条件描述，例如要求类型是整型、浮点型或支持某种操作。</li>
<li><strong>Constraints</strong> 则是通过 <code>requires</code> 或使用 Concepts 来对模板参数进行实际约束。</li>
</ul>
<p>它们让模板代码更安全、易于维护，并且编译时错误信息更清晰易懂。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Salianbooth</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://salianbooth.github.io/2024/09/13/CS106L-Lecture-5/">https://salianbooth.github.io/2024/09/13/CS106L-Lecture-5/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Cpp/"># Cpp</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/09/17/CS106L-Lecture-6/">CS106L:Lecture 6</a>
            
            
            <a class="next" rel="next" href="/2024/09/11/CS106L-Lecture-4/">CS106L:Lecture 4</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Salianbooth | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>