<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="referrer" content="no-referrer" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Salianbooth">





<title>CS106L:Lecture 4 | Alan Chen&#39;s blog</title>



    <link rel="icon" href="/image/favicon.png">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Salianbooth&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Salianbooth&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">CS106L:Lecture 4</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Salianbooth</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 11, 2024&nbsp;&nbsp;20:40:15</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/CS106L/">CS106L</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><ul>
<li><input checked="" disabled="" type="checkbox"> template的使用周期</li>
<li><input checked="" disabled="" type="checkbox"> 实例化</li>
<li><input checked="" disabled="" type="checkbox"> 模板就是你子定义的时候不清楚是什么类型，但是有人使用的时候会明确知道是什么类型了</li>
<li><input checked="" disabled="" type="checkbox"> 函数模板，其本质还说函数吗</li>
<li><input checked="" disabled="" type="checkbox"> 概念提升（concept lifting）</li>
<li><input checked="" disabled="" type="checkbox"> PPT P76</li>
<li><input checked="" disabled="" type="checkbox"> g++ std&#x3D;C++17 hello.cpp -o hello </li>
<li><input checked="" disabled="" type="checkbox"> 函数出现的错误</li>
<li><input checked="" disabled="" type="checkbox"> 决策和特定决策（decision ）</li>
<li><input checked="" disabled="" type="checkbox"> predicate</li>
<li><input disabled="" type="checkbox"> inline</li>
<li><input disabled="" type="checkbox"> thunks</li>
<li><input checked="" disabled="" type="checkbox"> <code> auto func = [&amp;,a]() &#123;&#125;</code></li>
<li><input checked="" disabled="" type="checkbox"> 隐式接口</li>
<li><input disabled="" type="checkbox"> tree set</li>
</ul>
<blockquote>
<p>这一次课主要讲述了 template模板，它为C++提供了强大的<strong>泛型编程</strong>，是C++的核心部分。其中在本次课程中主要讲述了一些C++中的编程思想，<strong>Concept Lifting</strong>和<strong>Implicit Interfaces</strong>这样的编程思想。</p>
</blockquote>
<h1 id="1-Template"><a href="#1-Template" class="headerlink" title="1.Template"></a>1.Template</h1><p>假如说我们有下面这一段代码，是用来求出2个数值中哪个更小一些，返回时小的在前面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">my_minmax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的代码只能处理int类型的pair，如果我们想要比较两个double或者是string类型的呢？我们可以想到重载，没错，通过重载的话我们可以得到下面的2组代码，这样就满足了我们想要比较double和string的需求了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">my_minmax</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">my_minmax</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样未免有一个问题，那么，我们怎么样才能比较我们自己定义的types呢？比方说两个class对象。我们可以观察发现，这三组代码中是由很多相似的地方的，那么我们能否将它们变成同一段代码呢？答案是可以的，这时候我们就要用到template模板了。</p>
<h2 id="1-1-模板简介"><a href="#1-1-模板简介" class="headerlink" title="1.1 模板简介"></a>1.1 模板简介</h2><p>模板（Template）是C++中的一种泛型编程特性，允许编写通用的、类型独立的代码。使用模板可以让一个函数、类、结构等操作多个类型，而不必为每个类型单独编写代码。<br>模板可以分成<strong>函数模板</strong>和<strong>类模板</strong>，这两个模板在<a href="https://salianbooth.github.io/2024/08/02/C-Primer-learning/">C++Primer</a>中都有简单的提及，这里我们就单独介绍函数模板。<br>在之前的例子中，我们可以将<code>my_minmax( int a,int b)</code>函数泛化成一个函数模板，下面是代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">pair&lt;T, T&gt; <span class="title">my_minmax</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) </span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> &#123;b, a&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里模板实例化为 int 类型</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result1 = <span class="built_in">my_minmax</span>(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里模板实例化为 double 类型</span></span><br><span class="line">    pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; result2 = <span class="built_in">my_minmax</span>(<span class="number">3.5</span>, <span class="number">2.1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里模板实例化为 string 类型</span></span><br><span class="line">    pair&lt;string, string&gt; result3 = <span class="built_in">my_minmax</span>(<span class="built_in">string</span>(<span class="string">&quot;apple&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;banana&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实模板的核心思想就是我们在定义的时候不指定具体的类型，但是根据传递的类型来确定是什么类型。这种设计允许编写更加灵活和通用的代码，避免为不同类型重复编写类似的代码。<br>虽然模板很方便，但是需要正确的使用，其中不正确使用模板会出现不少错误，我们在编译的时候，如果我们传入了不正确的参数，那么编译器会逐个类型去尝试匹配（直到找到匹配正确），这样会报错。下面是一个简单的使用错误的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">7.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误：int 和 double 是不同类型，无法推导出统一的 T</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-2实例化"><a href="#1-2实例化" class="headerlink" title="1.2实例化"></a>1.2实例化</h2><p>课程中就讲了如何隐式实例化，这里就直接chatgpt了一下其他的集中方法，说实话感觉这一节知识密度太低了。<br><strong>模板实例化</strong>是C++模板编程中的一个核心概念，它是指编译器根据模板的定义和传入的具体类型，生成对应的具体代码的过程。模板实例化会在程序编译过程中发生，并生成针对具体类型的函数或类代码。</p>
<h3 id="模板实例化的基本原理"><a href="#模板实例化的基本原理" class="headerlink" title="模板实例化的基本原理"></a>模板实例化的基本原理</h3><p>当你定义一个模板时，实际上并不会生成任何代码。模板就像一个蓝图或占位符，只有在实际使用模板时，编译器才会根据传入的具体类型生成对应的函数或类。这就是模板实例化的过程。</p>
<h4 id="模板实例化可以分为以下几种方式："><a href="#模板实例化可以分为以下几种方式：" class="headerlink" title="模板实例化可以分为以下几种方式："></a>模板实例化可以分为以下几种方式：</h4><ol>
<li><strong>隐式实例化</strong>（Implicit Instantiation）</li>
<li><strong>显式实例化</strong>（Explicit Instantiation）</li>
<li><strong>显式特化</strong>（Explicit Specialization）</li>
</ol>
<h3 id="1-隐式实例化"><a href="#1-隐式实例化" class="headerlink" title="1. 隐式实例化"></a>1. 隐式实例化</h3><p><strong>隐式实例化</strong>是最常见的模板实例化方式，发生在你<strong>调用</strong>模板时。编译器会根据传入的参数类型，自动推导模板的类型参数，并生成对应的代码。这种方式最常用，且不需要开发者额外干预。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.1</span>, b = <span class="number">2.2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; endl;    <span class="comment">// 编译器隐式实例化 add&lt;int&gt;(int, int)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; endl;    <span class="comment">// 编译器隐式实例化 add&lt;double&gt;(double, double)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>add</code> 函数模板被定义了，编译器会在调用 <code>add(x, y)</code> 时实例化 <code>add&lt;int&gt;</code>，在调用 <code>add(a, b)</code> 时实例化 <code>add&lt;double&gt;</code>。这种实例化是<strong>隐式的</strong>，编译器会根据传入的类型自动推导。</p>
<h3 id="2-显式实例化"><a href="#2-显式实例化" class="headerlink" title="2. 显式实例化"></a>2. 显式实例化</h3><p><strong>显式实例化</strong>是指开发者明确指定某个模板的类型参数，并让编译器提前生成特定类型的实例化代码。显式实例化可以确保模板的某个具体类型提前生成代码，而不是等到使用时才实例化。</p>
<p>显式实例化通常放在 <code>.cpp</code> 文件中，避免在每个包含模板的翻译单元中都实例化同一个类型的模板，减少编译时间和代码冗余。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span>/<span class="keyword">typename</span> 模板名&lt;类型&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个.cpp文件中，显式实例化 multiply&lt;int&gt; 和 multiply&lt;double&gt;</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">int</span> <span class="built_in">multiply</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">template</span> <span class="type">double</span> <span class="built_in">multiply</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>, <span class="type">double</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;         <span class="comment">// multiply&lt;int&gt; 已经显式实例化</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; endl;     <span class="comment">// multiply&lt;double&gt; 已经显式实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>multiply&lt;int&gt;</code> 和 <code>multiply&lt;double&gt;</code> 被<strong>显式实例化</strong>，即便程序中没有显式调用它们，编译器也会提前生成对应的代码。</p>
<h3 id="3-显式特化"><a href="#3-显式特化" class="headerlink" title="3. 显式特化"></a>3. 显式特化</h3><p><strong>显式特化</strong>用于某种类型的模板提供特殊实现。这与普通的实例化不同，显式特化定义了一个完全独立的、定制的版本。</p>
<h4 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对 const char* 类型的特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="built_in">max</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;             <span class="comment">// 使用通用模板</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>) &lt;&lt; endl;  <span class="comment">// 使用特化版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>max</code> 函数模板被定义为通用模板，适用于大部分类型。但对于 <code>const char*</code> 类型，提供了一个特殊的实现。当使用 <code>max(&quot;apple&quot;, &quot;banana&quot;)</code> 时，会调用这个特化版本，而不是通用版本。</p>
<h3 id="模板实例化的机制"><a href="#模板实例化的机制" class="headerlink" title="模板实例化的机制"></a>模板实例化的机制</h3><p>模板实例化是在编译期完成的，编译器在<strong>模板的使用点</strong>根据传入的类型生成模板代码。模板实例化的具体机制可以分为以下几个步骤：</p>
<ol>
<li><strong>类型推导</strong>：编译器根据模板函数或类的参数类型推导出模板参数。</li>
<li><strong>模板生成</strong>：根据推导出的模板参数，编译器生成一个具体的模板实例。</li>
<li><strong>代码生成</strong>：编译器为这个模板实例生成具体的代码。</li>
</ol>
<h3 id="重复实例化问题"><a href="#重复实例化问题" class="headerlink" title="重复实例化问题"></a>重复实例化问题</h3><p>模板实例化在每个使用模板的翻译单元（即每个 <code>.cpp</code> 文件）都会单独生成代码，这可能导致重复实例化问题，尤其在大型项目中，代码的重复生成会增加编译时间和最终的可执行文件大小。</p>
<p>为了解决这个问题，可以通过<strong>显式实例化</strong>或使用 <code>inline</code> 指令让编译器优化实例化行为。</p>
<h4 id="解决重复实例化的方法："><a href="#解决重复实例化的方法：" class="headerlink" title="解决重复实例化的方法："></a>解决重复实例化的方法：</h4><ol>
<li><strong>显式实例化</strong>：在某个 <code>.cpp</code> 文件中显式实例化模板，确保每个类型的实例化只生成一次。</li>
<li><strong><code>inline</code> 关键字</strong>：对于模板函数，可以使用 <code>inline</code> 关键字让编译器优化实例化行为，避免重复生成代码。</li>
</ol>
<h2 id="1-3函数模板本质"><a href="#1-3函数模板本质" class="headerlink" title="1.3函数模板本质"></a>1.3函数模板本质</h2><p><strong>函数模板</strong>在本质上与普通的函数有一些不同，虽然它们在语法上看起来相似，但它们的工作机制和编译过程存在显著差异。</p>
<h4 id="函数模板："><a href="#函数模板：" class="headerlink" title="函数模板："></a>函数模板：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数模板中，<code>T</code> 是一个<strong>占位符</strong>，代表任意类型。编译器在使用时，会根据传入的类型生成不同的 <code>add</code> 函数。例如：</p>
<ul>
<li><code>add(3, 4)</code> 会生成 <code>int add(int a, int b)</code>。</li>
<li><code>add(2.5, 3.5)</code> 会生成 <code>double add(double a, double b)</code>。<br>所以对于函数模板来说：</li>
<li><strong>函数模板</strong>本质上是一个<strong>生成函数的工具</strong>，它是参数化的，直到被使用时才生成真正的函数。</li>
<li><strong>普通函数</strong>是已经确定的函数，编译时就为它生成了代码。<br>因此，从本质上讲，<strong>函数模板并不是一个函数</strong>，而是一个可以生成具体函数的<strong>蓝图</strong>。一旦函数模板被实例化，所生成的具体函数才可以被视为函数。</li>
</ul>
<h1 id="2-concept-lifting"><a href="#2-concept-lifting" class="headerlink" title="2.concept lifting"></a>2.concept lifting</h1><p><strong>Concept Lifting</strong> 是 C++20 中与<strong>概念（Concepts）</strong>相关的一个高级技术话题。尽管这个术语没有明确的官方定义，但通常在泛型编程或模板编程的背景下，<strong>concept lifting</strong> 指的是 <strong>将泛型代码中的约束提升到概念层次</strong>，以便更好地表达代码意图、提高可读性、增强可重用性，并确保类型约束在编译时被准确验证。</p>
<p>在你提到的“Concept Lifting”的部分，讲解了如何通过放宽对函数参数的假设条件，使得函数能够适应更多的场景。这种技术通常用于模板编程中，使得代码更加通用和灵活。</p>
<h3 id="什么是“Concept-Lifting”？"><a href="#什么是“Concept-Lifting”？" class="headerlink" title="什么是“Concept Lifting”？"></a>什么是“Concept Lifting”？</h3><p><strong>“Concept Lifting”</strong> 的目的是通过审视并质疑我们对参数所作的假设，看看是否能够在不影响功能的前提下，放宽这些限制，从而解决更通用的问题。例如，假设我们有一个函数最初只针对 <code>vector&lt;int&gt;</code> 进行操作，但通过放宽对容器类型的限制，我们可以使这个函数处理所有类型的容器，这就是“Concept Lifting”的基本思想。</p>
<h3 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h3><p>从文档中我们看到，原始的函数可能如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOccurences</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123; </span><br><span class="line">        <span class="keyword">if</span> (vec[i] == val) ++count; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数计算一个整数在 <code>vector&lt;int&gt;</code> 中出现的次数。这个实现存在以下假设：</p>
<ol>
<li>容器类型是 <code>vector&lt;int&gt;</code>。</li>
<li>容器中的元素是 <code>int</code> 类型。</li>
</ol>
<p><strong>通过 Concept Lifting，我们可以把这个函数提升到更通用的形式</strong>：</p>
<h3 id="第一步：处理不同的数据类型"><a href="#第一步：处理不同的数据类型" class="headerlink" title="第一步：处理不同的数据类型"></a>第一步：处理不同的数据类型</h3><p>首先，我们可以通过模板将数据类型泛化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOccurences</span><span class="params">(<span class="type">const</span> vector&lt;DataType&gt;&amp; vec, DataType val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123; </span><br><span class="line">        <span class="keyword">if</span> (vec[i] == val) ++count; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以处理任何类型的 <code>vector</code>，而不仅仅是 <code>int</code> 类型。<br>但是这个时候如果我们传入的是list类型，那么就会发生错误，这是因为list底层是通过链表实现的，不能通过<code>[]</code>下标进行访问。</p>
<h3 id="第二步：处理不同的容器类型"><a href="#第二步：处理不同的容器类型" class="headerlink" title="第二步：处理不同的容器类型"></a>第二步：处理不同的容器类型</h3><p>接下来，我们可以进一步泛化容器的类型，使得这个函数能够处理任何 STL 容器，而不仅仅是 <code>vector</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Collection, <span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOccurences</span><span class="params">(<span class="type">const</span> Collection&amp; collection, DataType val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = collection.<span class="built_in">begin</span>(); iter != collection.<span class="built_in">end</span>(); ++iter) &#123; </span><br><span class="line">        <span class="keyword">if</span> (*iter == val) ++count; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这一改动，<code>countOccurences</code> 函数现在可以处理各种容器类型（如 <code>list</code>、<code>deque</code> 等），并计算任何类型元素的出现次数。</p>
<h3 id="第三步：使用迭代器"><a href="#第三步：使用迭代器" class="headerlink" title="第三步：使用迭代器"></a>第三步：使用迭代器</h3><p>最后，为了更进一步，我们可以使用迭代器来实现函数，这样可以处理任何支持迭代器的范围，而不仅仅是容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOccurences</span><span class="params">(InputIt begin, InputIt end, DataType val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin; iter != end; ++iter) &#123; </span><br><span class="line">        <span class="keyword">if</span> (*iter == val) ++count; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本更加通用，它可以处理任何输入迭代器范围，无论它们来自哪种容器或集合。</p>
<h1 id="3-Lambda"><a href="#3-Lambda" class="headerlink" title="3.Lambda"></a>3.Lambda</h1><p>lambda<a href="https://salianbooth.github.io/2024/08/02/C-Primer-learning/">C++Primer</a>之前也有所提过：<br>Lambda 表达式是 C++11 引入的一种功能，允许你在代码中定义匿名函数。它们通常用于简化代码，使代码更简洁、更易读。Lambda 表达式的基本语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>capture</code>**：捕获列表，用于捕获上下文中的变量。</li>
<li>**<code>parameters</code>**：参数列表，与普通函数的参数列表类似。</li>
<li>**<code>return_type</code>**：返回类型，可以省略，如果可以从返回的表达式中推断出来。</li>
<li>**<code>body</code>**：函数体，包含要执行的代码。<br>我们这里要讲一些其他的东西，比方说，谓词predicate。</li>
</ul>
<h2 id="3-1-predicate"><a href="#3-1-predicate" class="headerlink" title="3.1 predicate"></a>3.1 predicate</h2><p>在 C++ 中，<strong>predicate（谓词）</strong> 是一个返回布尔值的函数或函数对象，通常用于检查某种条件或性质。谓词主要用于算法中，来判断给定元素是否满足某些条件。这种条件可以是简单的比较，也可以是更复杂的逻辑判断。<br>C++ 中的谓词可以分为以下两类：</p>
<ol>
<li><p><strong>一元谓词（Unary Predicate）</strong>：</p>
<ul>
<li>接受一个参数，返回一个布尔值。</li>
<li>例如，<code>std::find_if</code>、<code>std::count_if</code> 等标准算法函数可以使用一元谓词。</li>
<li>常用于判断单个元素是否符合某个条件。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元谓词函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::find_if 查找第一个偶数</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), isEven);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First even number is &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>二元谓词（Binary Predicate）</strong>：</p>
<ul>
<li><p>接受两个参数，返回一个布尔值。</p>
</li>
<li><p>例如，<code>std::sort</code>、<code>std::set_intersection</code> 等标准算法函数可以使用二元谓词。</p>
</li>
<li><p>常用于比较两个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">customCompare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::sort 并传递二元谓词</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), customCompare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里ppt中用了一段代码来解释了谓词Predicate怎么使用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countOccurrences</span><span class="params">(InputIt begin, InputIt end, UniPred predicate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter = begin; iter != end; ++iter) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="built_in">predicate</span>(*iter)) </span><br><span class="line">	        ++count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里使用了模板定义，参数有三个：</p>
<ul>
<li><p><code>InputIt</code>：表示输入迭代器类型，通常用于遍历容器中的元素。</p>
</li>
<li><p><code>DataType</code>：表示要处理的数据类型。虽然这个参数在代码中没有直接使用，但它可以用于特定情况下的特化或限制。</p>
</li>
<li><p><code>UniPred</code>：表示一个谓词（predicate），它是一个可以接受某种类型参数并返回布尔值的函数或函数对象（例如 Lambda 表达式或函数指针）。</p>
</li>
</ul>
</li>
</ul>
<p>如何在main函数中使用呢？我们假设有一个数组，我们想要统计其中大于5的元素个数，可以这样使用这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 lambda 表达式作为谓词函数</span></span><br><span class="line">    <span class="keyword">auto</span> greaterThanFive = [](<span class="type">int</span> val) &#123; <span class="keyword">return</span> val &gt; <span class="number">5</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用模板函数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">countOccurrences</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greaterThanFive);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements greater than 5: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话就能大大提高我们代码中的逻辑和泛式编程</p>
<h2 id="3-2lambda-capture"><a href="#3-2lambda-capture" class="headerlink" title="3.2lambda capture"></a>3.2lambda capture</h2><p>在C++的lambda表达式中，捕获外部变量的方式分为<strong>按值传递</strong>和<strong>按引用传递</strong>，分别对应不同的捕获机制。它们决定了lambda内部如何访问外部作用域的变量，以及是否可以修改这些变量。</p>
<h3 id="1-按值捕获（值传递）"><a href="#1-按值捕获（值传递）" class="headerlink" title="1. 按值捕获（值传递）"></a>1. <strong>按值捕获（值传递）</strong></h3><p>按值捕获意味着在创建lambda时，会对外部作用域的变量进行<strong>拷贝</strong>，lambda内部使用的是这些变量的<strong>副本</strong>。因此，在lambda表达式内部修改这些变量不会影响外部的原始变量。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><p>捕获列表中的变量名前面没有符号时，表示按值捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b]() &#123; <span class="comment">/* 按值捕获a和b */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>或者用<code>=</code>符号表示<strong>按值捕获所有外部变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[=]() &#123; <span class="comment">/* 按值捕获所有外部变量 */</span> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() &#123; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; </span><br><span class="line">        <span class="comment">// 此处x是一个副本，修改它不会影响外部的x</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    x = <span class="number">20</span>;  <span class="comment">// 修改外部的x</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用lambda</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出x的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside lambda, x = 10</span><br><span class="line">Outside lambda, x = 20</span><br></pre></td></tr></table></figure>

<ul>
<li>在lambda表达式内，<code>x</code>是按值捕获的，因此它是一个副本。即使外部的<code>x</code>后来修改为20，lambda内部的<code>x</code>仍然是最初捕获时的值10。</li>
</ul>
<h3 id="2-按引用捕获（引用传递）"><a href="#2-按引用捕获（引用传递）" class="headerlink" title="2. 按引用捕获（引用传递）"></a>2. <strong>按引用捕获（引用传递）</strong></h3><p>按引用捕获意味着lambda表达式内部直接引用外部作用域中的变量，因此在lambda中对这些变量的修改会直接影响外部变量的值。</p>
<h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><p>捕获列表中的变量名前面有<code>&amp;</code>符号，表示按引用捕获：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&amp;a, &amp;b]() &#123; <span class="comment">/* 按引用捕获a和b */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>或者用<code>&amp;</code>符号表示<strong>按引用捕获所有外部变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&amp;]() &#123; <span class="comment">/* 按引用捕获所有外部变量 */</span> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;x]() &#123; </span><br><span class="line">        x = <span class="number">30</span>;  <span class="comment">// 修改外部的x</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    x = <span class="number">20</span>;  <span class="comment">// 修改外部的x</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用lambda</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside lambda, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出x的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside lambda, x = 30</span><br><span class="line">Outside lambda, x = 30</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的<code>x</code>是按引用捕获的，因此lambda内部修改了<code>x</code>，外部的<code>x</code>也随之被修改。</li>
</ul>
<h3 id="3-混合捕获"><a href="#3-混合捕获" class="headerlink" title="3. 混合捕获"></a>3. <strong>混合捕获</strong></h3><p>你可以在一个lambda中同时按值和按引用捕获不同的变量。通过捕获列表指定每个变量的捕获方式。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x, &amp;y]() &#123; </span><br><span class="line">        <span class="comment">// x 按值捕获，y 按引用捕获</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 修改y的值</span></span><br><span class="line">        y = <span class="number">30</span>; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">40</span>; <span class="comment">// 修改外部x</span></span><br><span class="line">    y = <span class="number">50</span>; <span class="comment">// 修改外部y</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 调用lambda</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outside lambda: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside lambda: x = 10, y = 50</span><br><span class="line">Outside lambda: x = 40, y = 30</span><br></pre></td></tr></table></figure>

<ul>
<li><code>x</code>是按值捕获的，因此lambda内的<code>x</code>仍然是10（捕获时的值），即使外部的<code>x</code>被修改为40。</li>
<li><code>y</code>是按引用捕获的，因此lambda内部修改了<code>y</code>的值，外部的<code>y</code>也被修改为30。</li>
</ul>
<h3 id="4-按值捕获与按引用捕获的区别"><a href="#4-按值捕获与按引用捕获的区别" class="headerlink" title="4. 按值捕获与按引用捕获的区别"></a>4. <strong>按值捕获与按引用捕获的区别</strong></h3><ul>
<li><strong>按值捕获</strong>：lambda内部使用的是变量的副本，不能修改外部变量的值。</li>
<li><strong>按引用捕获</strong>：lambda内部使用的是外部变量的引用，修改lambda内部的变量会影响外部变量。</li>
</ul>
<h3 id="5-捕获方式的选择"><a href="#5-捕获方式的选择" class="headerlink" title="5. 捕获方式的选择"></a>5. <strong>捕获方式的选择</strong></h3><p>选择按值捕获或按引用捕获取决于你的需求：</p>
<ul>
<li>如果不希望lambda修改外部的变量，或者需要在lambda执行时保持变量的原始值，可以使用<strong>按值捕获</strong>。</li>
<li>如果希望lambda能够修改外部的变量值，或者希望lambda始终访问最新的外部变量状态，使用<strong>按引用捕获</strong>。</li>
</ul>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><ul>
<li><input disabled="" type="checkbox"> auto不能再参数中使用</li>
<li><input disabled="" type="checkbox"> [ ] C++中C语言的字符串和字符串的区别 -&gt;c String</li>
<li><input disabled="" type="checkbox"> [ ] strteam can’t be copieds</li>
<li><input disabled="" type="checkbox"> [ ] 迭代器传给函数时，它是自动按引用传递的吗 -&gt; 实际上是copy？</li>
<li><input disabled="" type="checkbox"> 那些类型不支持<code>[]</code>访问呢？</li>
</ul>
<p>上课这么自由吗</p>
<p><img src="https://gitee.com/salianbooth/picture/raw/master/202409112110442.png" alt="Clip_2024-09-11_21-10-04.png"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Salianbooth</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://salianbooth.github.io/2024/09/11/CS106L-Lecture-4/">https://salianbooth.github.io/2024/09/11/CS106L-Lecture-4/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Cpp/"># Cpp</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/09/13/CS106L-Lecture-5/">CS106L:Lecture 5</a>
            
            
            <a class="next" rel="next" href="/2024/09/04/CS106L-Lecture-3/">CS106L:Lecture 3</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Salianbooth | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>